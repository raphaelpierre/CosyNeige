generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String        @id @default(cuid())
  email             String        @unique
  password          String?       // Optionnel - null si pas encore défini
  firstName         String
  lastName          String
  phone             String?
  role              String        @default("client") // client, admin
  passwordSet       Boolean       @default(false) // True si l'utilisateur a défini son mot de passe
  passwordResetToken String?      // Token pour définir/réinitialiser le mot de passe
  tokenExpiry       DateTime?     // Expiration du token
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  reservations      Reservation[]
  conversations     Conversation[]
}

model Reservation {
  id              String    @id @default(cuid())
  guestName       String
  firstName       String
  lastName        String
  email           String
  phone           String
  checkIn         DateTime
  checkOut        DateTime
  guests          Int
  totalPrice      Float
  status          String    @default("pending")
  paymentStatus   String?   @default("none")
  stripePaymentId String?
  depositAmount   Float?
  message         String?
  userId          String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  user            User?     @relation(fields: [userId], references: [id])
  invoices        Invoice[]
  conversations   Conversation[]
}

// LEGACY MODELS - Supprimés et remplacés par Conversation/ConversationMessage
// model Message { ... }
// model ContactMessage { ... }

model BookedPeriod {
  id        String   @id @default(cuid())
  startDate DateTime
  endDate   DateTime
  createdAt DateTime @default(now())
}

model SeasonPeriod {
  id              String   @id @default(cuid())
  name            String   // ex: "Vacances de Noël 2024", "Février 2025"
  startDate       DateTime
  endDate         DateTime
  seasonType      String   // "high" ou "low"
  pricePerNight   Float    // Prix par nuit pour cette période
  minimumStay     Int      // Nombre de nuits minimum
  sundayToSunday  Boolean  @default(false) // Si vrai, uniquement dimanche à dimanche
  year            Int      // Année pour faciliter les requêtes
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model PricingSettings {
  id              String   @id @default(cuid())
  cleaningFee     Float    @default(450)
  linenPerPerson  Float    @default(25)
  touristTaxPerPersonPerNight Float @default(3) // Taxe de séjour par personne par nuit
  depositAmount   Float    @default(1500)
  defaultHighSeasonPrice Float @default(410)
  defaultLowSeasonPrice  Float @default(310)
  defaultMinimumStay     Int   @default(3)
  highSeasonMinimumStay  Int   @default(7) // Nombre de jours minimum en haute saison
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model Invoice {
  id              String   @id @default(cuid())
  invoiceNumber   String   @unique // CHB-2025-001
  invoiceType     String   @default("full") // "deposit", "balance", "full", "custom"

  // Relation avec la réservation
  reservationId   String
  reservation     Reservation @relation(fields: [reservationId], references: [id], onDelete: Cascade)

  // Informations client (dénormalisées pour historique)
  clientName      String
  clientEmail     String
  clientPhone     String?
  clientAddress   String?

  // Détails de la période
  checkIn         DateTime
  checkOut        DateTime
  nights          Int
  guests          Int

  // Montants détaillés
  baseAmount      Float    // Montant de base (nuitées)
  pricePerNight   Float    // Prix par nuit
  cleaningFee     Float    @default(0)
  linenFee        Float    @default(0)
  taxAmount       Float    @default(0)
  totalAmount     Float    // Total TTC

  // Statut et paiement
  status          String   @default("draft") // draft, sent, paid, partial, cancelled
  paymentMethod   String?  // stripe, bank_transfer, cash, check
  paymentReference String? // ID transaction Stripe, n° chèque, etc.
  paidAmount      Float    @default(0)
  paidAt          DateTime?

  // Fichier PDF
  pdfUrl          String?  // Chemin vers le PDF stocké
  pdfGeneratedAt  DateTime?

  // Dates importantes
  issuedAt        DateTime @default(now())
  dueDate         DateTime?
  sentAt          DateTime? // Date d'envoi par email

  // Notes et métadonnées
  notes           String?  @db.Text // Notes visibles sur la facture
  internalNotes   String?  @db.Text // Notes privées admin uniquement

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([reservationId])
  @@index([status])
  @@index([invoiceNumber])
}

// Modèle de transaction comptable
model AccountingTransaction {
  id              String   @id @default(cuid())

  // Type de transaction
  type            String   // "income" (recette) ou "expense" (dépense)
  category        String   // "booking", "maintenance", "utilities", "taxes", "insurance", "supplies", "marketing", "other"

  // Montant et détails
  amount          Float
  description     String
  notes           String?  @db.Text

  // Liens optionnels
  reservationId   String?  // Lié à une réservation si applicable
  invoiceId       String?  // Lié à une facture si applicable

  // Informations de paiement
  paymentMethod   String?  // "stripe", "bank_transfer", "cash", "check", "card"
  paymentReference String? // Numéro de transaction, chèque, etc.

  // Date de la transaction
  transactionDate DateTime @default(now())

  // Pièces jointes
  attachmentUrl   String?  // URL vers un justificatif (facture, reçu)

  // Métadonnées
  createdBy       String?  // ID de l'admin qui a créé
  validated       Boolean  @default(false) // Transaction validée par l'admin

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([type])
  @@index([category])
  @@index([transactionDate])
  @@index([reservationId])
}

// Modèle de logs d'emails
model EmailLog {
  id              String   @id @default(cuid())

  // Type d'email
  emailType       String   // "booking_confirmation", "admin_notification", "contact", "account_creation", "custom"

  // Expéditeur et destinataire
  from            String   // Adresse email "from"
  to              String   // Adresse email "to"
  replyTo         String?  // Adresse "reply-to" si applicable

  // Contenu
  subject         String
  htmlContent     String?  @db.Text // Contenu HTML de l'email
  textContent     String?  @db.Text // Contenu texte de l'email

  // Statut d'envoi
  status          String   @default("pending") // "pending", "sent", "failed", "bounced"
  resendId        String?  // ID retourné par Resend API
  errorMessage    String?  @db.Text // Message d'erreur si échec

  // Liens avec autres entités
  reservationId   String?  // Lié à une réservation si applicable
  userId          String?  // Lié à un utilisateur si applicable

  // Métadonnées
  sentAt          DateTime? // Date d'envoi effectif
  openedAt        DateTime? // Date d'ouverture (si tracking activé)
  clickedAt       DateTime? // Date du premier clic (si tracking activé)

  // Tentatives de réenvoi
  retryCount      Int      @default(0)
  lastRetryAt     DateTime?

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relation avec ConversationMessage
  conversationMessage ConversationMessage?

  @@index([emailType])
  @@index([status])
  @@index([reservationId])
  @@index([userId])
  @@index([to])
  @@index([createdAt])
}

// Nouveau système de conversations unifié
model Conversation {
  id              String   @id @default(cuid())

  // Relations
  userId          String   // Client concerné
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  reservationId   String?  // Lié à une réservation optionnelle (si conversation liée à une résa)
  reservation     Reservation? @relation(fields: [reservationId], references: [id], onDelete: SetNull)

  // Informations
  subject         String   // Sujet de la conversation
  status          String   @default("open") // "open", "closed", "archived"

  // Tracking
  unreadByAdmin   Int      @default(0) // Nombre de messages non lus par admin
  unreadByClient  Int      @default(0) // Nombre de messages non lus par client
  lastMessageAt   DateTime @default(now())
  lastMessageFrom String?  // "client" ou "admin"

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  messages        ConversationMessage[]

  @@index([userId])
  @@index([reservationId])
  @@index([status])
  @@index([lastMessageAt])
}

model ConversationMessage {
  id              String   @id @default(cuid())

  // Relation avec la conversation
  conversationId  String
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Expéditeur
  fromUserId      String?  // ID de l'utilisateur si connecté
  fromEmail       String   // Email de l'expéditeur
  fromName        String   // Nom de l'expéditeur
  isFromAdmin     Boolean  @default(false)

  // Contenu
  content         String   @db.Text

  // Email envoyé
  emailLogId      String?  @unique // Lié à l'email envoyé via Resend
  emailLog        EmailLog? @relation(fields: [emailLogId], references: [id], onDelete: SetNull)

  // Statut
  read            Boolean  @default(false)
  readAt          DateTime?

  createdAt       DateTime @default(now())

  @@index([conversationId])
  @@index([fromUserId])
  @@index([isFromAdmin])
  @@index([createdAt])
}
